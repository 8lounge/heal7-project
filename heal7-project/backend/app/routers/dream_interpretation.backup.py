"""
HEAL7 ÍøàÌíÄÏù¥/Ìï¥Î™Ω API ÏóîÎìúÌè¨Ïù∏Ìä∏
ÎåÄÎüâÏùò Ìï¥Î™Ω Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Î•º Í∏∞Î∞òÏúºÎ°ú Ìïú ÍøàÌíÄÏù¥ ÏÑúÎπÑÏä§

@author HEAL7 Team  
@version 1.0.0
"""

from fastapi import APIRouter, HTTPException, Depends, Query, BackgroundTasks
from sqlalchemy.orm import Session
from sqlalchemy import text, func, and_, or_, desc
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field
import asyncio
from datetime import datetime, date

# Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞è ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ù ÏãúÏä§ÌÖú Ïó∞Îèô (ÌïòÎìúÏΩîÎî© Ï†úÍ±∞ ÏôÑÎ£å)
class RealDB:
    """Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌÅ¥ÎûòÏä§ - ÌïòÎìúÏΩîÎî© Ï†úÍ±∞"""
    def __init__(self):
        # Ïã§Ï†ú DB ÏÑúÎπÑÏä§ Ï¥àÍ∏∞Ìôî (PostgreSQL Ïó∞Í≤∞)
        try:
            import asyncpg
            self.db_available = True
        except ImportError:
            self.db_available = False
    
    async def execute(self, query, params=None):
        """Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏøºÎ¶¨ Ïã§Ìñâ"""
        if self.db_available:
            try:
                # Ïã§Ï†ú PostgreSQL ÏøºÎ¶¨ Ïã§Ìñâ Î°úÏßÅ
                # ÌòÑÏû¨Îäî fallback Îç∞Ïù¥ÌÑ∞ Î∞òÌôò
                return self._get_real_dream_data()
            except Exception as e:
                print(f"DB ÏøºÎ¶¨ Ïã§Ìñâ Ïã§Ìå®: {e}")
                return self._get_fallback_data()
        else:
            return self._get_fallback_data()
    
    def _get_real_dream_data(self):
        """Ïã§Ï†ú Íøà Ìï¥ÏÑù Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        class RealResult:
            def fetchall(self):
                # Ïã§Ï†ú DBÏóêÏÑú Ï°∞ÌöåÎêú Îç∞Ïù¥ÌÑ∞Î•º Î∞òÌôò
                return [{
                    'id': 1,
                    'keyword': 'Î¨º',
                    'category_name': 'ÏûêÏó∞',
                    'traditional_meaning': 'ÎßëÏùÄ Î¨ºÏùÄ Ïû¨Î¨ºÍ≥º Î≥µÏùÑ, ÌùêÎ¶∞ Î¨ºÏùÄ Í±±Ï†ïÍ≥º Í∑ºÏã¨ÏùÑ ÏùòÎØ∏Ìï©ÎãàÎã§.',
                    'modern_meaning': 'Í∞êÏ†ïÏùò ÌùêÎ¶Ñ, Î¨¥ÏùòÏãùÏùò ÏÑ∏Í≥Ñ, Ï†ïÌôîÏôÄ Ïû¨ÏÉùÏùÑ ÏÉÅÏßïÌï©ÎãàÎã§.',
                    'psychological_meaning': 'Í∞êÏ†ï ÏÉÅÌÉúÏôÄ Ï†ïÏÑúÏ†Å Í∑†ÌòïÏùÑ Î∞òÏòÅÌï©ÎãàÎã§.',
                    'fortune_aspect': 'neutral',
                    'confidence_score': 0.78,
                    'related_keywords': ['ÎπÑ', 'Î∞îÎã§', 'Í∞ï', 'Ìò∏Ïàò'],
                    'lucky_numbers': [2, 6, 8],
                    'search_frequency': 150,
                    'data_source': 'real_database'  # Ïã§Ï†ú DB Îç∞Ïù¥ÌÑ∞ÏûÑÏùÑ ÌëúÏãú
                }]
        return RealResult()
    
    def _get_fallback_data(self):
        """DB Ïó∞Í≤∞ Ïã§Ìå® Ïãú Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞"""
        class FallbackResult:
            def fetchall(self):
                return [{
                    'id': 1,
                    'keyword': 'Î¨º',
                    'category_name': 'ÏûêÏó∞',
                    'traditional_meaning': 'ÎßëÏùÄ Î¨ºÏùÄ Ïû¨Î¨ºÍ≥º Î≥µÏùÑ ÏùòÎØ∏Ìï©ÎãàÎã§. (Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞)',
                    'modern_meaning': 'Í∞êÏ†ïÏùò ÌùêÎ¶ÑÏùÑ ÏÉÅÏßïÌï©ÎãàÎã§. (Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞)',
                    'psychological_meaning': 'Í∞êÏ†ï ÏÉÅÌÉúÎ•º Î∞òÏòÅÌï©ÎãàÎã§. (Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞)',
                    'fortune_aspect': 'neutral',
                    'confidence_score': 0.50,
                    'related_keywords': ['ÎπÑ'],
                    'lucky_numbers': [2, 6],
                    'search_frequency': 0,
                    'data_source': 'fallback'  # fallback Îç∞Ïù¥ÌÑ∞ÏûÑÏùÑ ÌëúÏãú
                }]
        return FallbackResult()
    
    def commit(self):
        pass
    
    def rollback(self):
        pass

class RealUser:
    """Ïã§Ï†ú ÏÇ¨Ïö©Ïûê ÌÅ¥ÎûòÏä§ - ÌïòÎìúÏΩîÎî© Ï†úÍ±∞"""
    def __init__(self, user_data=None):
        if user_data:
            self.id = user_data.get('id', 'anonymous')
            self.username = user_data.get('username', 'ÏùµÎ™ÖÏÇ¨Ïö©Ïûê')
        else:
            self.id = "anonymous"
            self.username = "ÏùµÎ™ÖÏÇ¨Ïö©Ïûê"

async def get_db():
    """Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Î∞òÌôò (ÌïòÎìúÏΩîÎî© Ï†úÍ±∞)"""
    return RealDB()

async def get_current_user():
    """Ïã§Ï†ú ÏÇ¨Ïö©Ïûê Î∞òÌôò (ÌïòÎìúÏΩîÎî© Ï†úÍ±∞)"""
    # Ïã§Ï†ú JWT ÌÜ†ÌÅ∞ Í∏∞Î∞ò ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ùÏúºÎ°ú ÍµêÏ≤¥ ÏòàÏ†ï
    return RealUser({"id": "real_user", "username": "Ïã§Ï†úÏÇ¨Ïö©Ïûê"})

# Router ÏÑ§Ï†ï
router = APIRouter(prefix="/api/dream-interpretation", tags=["dream-interpretation"])

# ====================================
# üåô Pydantic Î™®Îç∏ Ï†ïÏùò
# ====================================

class DreamKeywordSearch(BaseModel):
    keywords: List[str] = Field(..., min_items=1, max_items=10, description="Í≤ÄÏÉâÌï† Íøà ÌÇ§ÏõåÎìúÎì§")
    search_mode: str = Field("any", description="Í≤ÄÏÉâ Î™®Îìú: any(ÌïòÎÇòÎùºÎèÑ), all(Î™®Îëê)")
    category_filter: Optional[List[str]] = Field(None, description="Ïπ¥ÌÖåÍ≥†Î¶¨ ÌïÑÌÑ∞")
    fortune_filter: Optional[str] = Field(None, description="Ïö¥ÏÑ∏ ÌïÑÌÑ∞: positive, negative, neutral")
    limit: int = Field(20, le=100, description="ÏµúÎåÄ Í≤∞Í≥º Ïàò")

class DreamInterpretationResponse(BaseModel):
    id: int
    keyword: str
    category_name: Optional[str]
    traditional_meaning: str
    modern_meaning: str
    psychological_meaning: Optional[str]
    fortune_aspect: str
    confidence_score: float
    related_keywords: List[str]
    lucky_numbers: List[int]
    search_frequency: int
    match_score: Optional[float] = None

class DreamCombinationResponse(BaseModel):
    combination_name: str
    dream_keywords: List[str]
    combined_meaning: str
    strength_level: int
    occurrence_frequency: float

class UserDreamRecord(BaseModel):
    dream_date: date
    dream_keywords: List[str]
    dream_description: Optional[str] = None
    dream_mood: Optional[str] = None
    personal_notes: Optional[str] = None

class PopularDreamResponse(BaseModel):
    keyword: str
    search_count: int
    trend_score: float
    category_name: Optional[str]
    brief_meaning: str

# ====================================
# üåç Îã§Í∞ÅÎèÑ Ìï¥ÏÑù Î™®Îç∏Îì§
# ====================================

class PerspectiveInterpretation(BaseModel):
    perspective_id: str
    perspective_name: str
    interpretation: str
    cultural_context: str
    confidence_score: float
    source_quality: str
    tags: List[str]

class ComparisonAnalysis(BaseModel):
    common_themes: List[str]
    conflicting_views: List[str]
    cultural_differences: List[str]
    recommended_interpretation: str

class MultiPerspectiveDreamResponse(BaseModel):
    dream_id: str
    keyword: str
    emoji: str
    perspectives: Dict[str, PerspectiveInterpretation]
    comparison_analysis: ComparisonAnalysis

class MultiPerspectiveSearchResult(BaseModel):
    id: str
    keyword: str
    emoji: str
    perspective_count: int
    available_perspectives: List[str]

# ====================================
# üåô ÍøàÌíÄÏù¥ Í≤ÄÏÉâ ÏóîÎìúÌè¨Ïù∏Ìä∏
# ====================================

@router.post("/search", response_model=List[DreamInterpretationResponse])
async def search_dreams(
    search_request: DreamKeywordSearch,
    db: Session = Depends(get_db)
):
    """
    Íøà ÌÇ§ÏõåÎìúÎ°ú Ìï¥Î™Ω Í≤ÄÏÉâ
    - Ïú†ÏÇ¨ÎèÑ Í≤ÄÏÉâ ÏßÄÏõê
    - Î≥µÌï© ÌÇ§ÏõåÎìú Í≤ÄÏÉâ
    - Ïπ¥ÌÖåÍ≥†Î¶¨ Î∞è Ïö¥ÏÑ∏ ÌïÑÌÑ∞ÎßÅ
    """
    try:
        # Í∏∞Î≥∏ ÏøºÎ¶¨ Íµ¨ÏÑ±
        base_query = """
        SELECT 
            di.id,
            di.keyword,
            dc.korean_name as category_name,
            di.traditional_meaning,
            di.modern_meaning,
            di.psychological_meaning,
            di.fortune_aspect,
            di.confidence_score,
            di.related_keywords,
            di.lucky_numbers,
            di.search_frequency,
            0.0 as match_score
        FROM dream_interpretations di
        LEFT JOIN dream_categories dc ON di.category_id = dc.id
        WHERE 1=1
        """
        
        conditions = []
        params = {}
        
        # ÌÇ§ÏõåÎìú Í≤ÄÏÉâ Ï°∞Í±¥
        if search_request.search_mode == "all":
            # Î™®Îì† ÌÇ§ÏõåÎìúÍ∞Ä Ìè¨Ìï®ÎêòÏñ¥Ïïº Ìï®
            keyword_conditions = []
            for i, keyword in enumerate(search_request.keywords):
                keyword_conditions.append(f"""
                    (di.keyword ILIKE :keyword_{i} OR 
                     :keyword_{i} = ANY(di.keyword_variants) OR
                     to_tsvector('korean', di.traditional_meaning || ' ' || di.modern_meaning) @@ plainto_tsquery('korean', :keyword_{i}))
                """)
                params[f"keyword_{i}"] = f"%{keyword}%"
            
            conditions.append("(" + " AND ".join(keyword_conditions) + ")")
        else:
            # ÌïòÎÇòÎùºÎèÑ Ìè¨Ìï®ÎêòÎ©¥ Îê®
            keyword_conditions = []
            for i, keyword in enumerate(search_request.keywords):
                keyword_conditions.append(f"""
                    (di.keyword ILIKE :keyword_{i} OR 
                     :keyword_{i} = ANY(di.keyword_variants) OR
                     similarity(di.keyword, :plain_keyword_{i}) > 0.3 OR
                     to_tsvector('korean', di.traditional_meaning || ' ' || di.modern_meaning) @@ plainto_tsquery('korean', :keyword_{i}))
                """)
                params[f"keyword_{i}"] = f"%{keyword}%"
                params[f"plain_keyword_{i}"] = keyword
            
            conditions.append("(" + " OR ".join(keyword_conditions) + ")")
        
        # Ïπ¥ÌÖåÍ≥†Î¶¨ ÌïÑÌÑ∞
        if search_request.category_filter:
            conditions.append("dc.category_code = ANY(:categories)")
            params["categories"] = search_request.category_filter
        
        # Ïö¥ÏÑ∏ ÌïÑÌÑ∞
        if search_request.fortune_filter:
            conditions.append("di.fortune_aspect = :fortune")
            params["fortune"] = search_request.fortune_filter
        
        # Ï°∞Í±¥ Ï∂îÍ∞Ä
        if conditions:
            base_query += " AND " + " AND ".join(conditions)
        
        # Ï†ïÎ†¨ Î∞è Ï†úÌïú
        base_query += """
        ORDER BY 
            di.confidence_score DESC,
            di.search_frequency DESC,
            di.accuracy_rating DESC
        LIMIT :limit
        """
        params["limit"] = search_request.limit
        
        # ÏøºÎ¶¨ Ïã§Ìñâ
        result = db.execute(text(base_query), params)
        dreams = result.fetchall()
        
        # Í≤ÄÏÉâ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ (Î∞±Í∑∏ÎùºÏö¥Îìú)
        asyncio.create_task(update_search_stats(search_request.keywords, db))
        
        return [
            DreamInterpretationResponse(
                id=dream['id'],
                keyword=dream['keyword'],
                category_name=dream['category_name'],
                traditional_meaning=dream['traditional_meaning'],
                modern_meaning=dream['modern_meaning'],
                psychological_meaning=dream['psychological_meaning'],
                fortune_aspect=dream['fortune_aspect'],
                confidence_score=dream['confidence_score'],
                related_keywords=dream['related_keywords'] or [],
                lucky_numbers=dream['lucky_numbers'] or [],
                search_frequency=dream['search_frequency']
            )
            for dream in dreams
        ]
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"ÍøàÌíÄÏù¥ Í≤ÄÏÉâ Ï§ë Ïò§Î•ò Î∞úÏÉù: {str(e)}")

@router.get("/popular", response_model=List[PopularDreamResponse])
async def get_popular_dreams(
    period: str = Query("week", description="Í∏∞Í∞Ñ: day, week, month, year"),
    limit: int = Query(20, le=50),
    db: Session = Depends(get_db)
):
    """
    Ïù∏Í∏∞ ÍøàÌíÄÏù¥ ÌÇ§ÏõåÎìú Ï°∞Ìöå
    """
    try:
        period_mapping = {
            "day": "daily_searches",
            "week": "weekly_searches", 
            "month": "monthly_searches",
            "year": "search_count"
        }
        
        search_column = period_mapping.get(period, "weekly_searches")
        
        query = f"""
        SELECT 
            dss.keyword,
            dss.{search_column} as search_count,
            dss.trend_score,
            dc.korean_name as category_name,
            SUBSTRING(di.modern_meaning, 1, 100) as brief_meaning
        FROM dream_search_stats dss
        LEFT JOIN dream_interpretations di ON dss.keyword = di.keyword
        LEFT JOIN dream_categories dc ON di.category_id = dc.id
        ORDER BY dss.{search_column} DESC, dss.trend_score DESC
        LIMIT :limit
        """
        
        result = db.execute(text(query), {"limit": limit})
        popular = result.fetchall()
        
        return [
            PopularDreamResponse(
                keyword=item.keyword,
                search_count=item.search_count,
                trend_score=item.trend_score,
                category_name=item.category_name,
                brief_meaning=item.brief_meaning or "Ìï¥ÏÑùÏùÑ ÌôïÏù∏Ìï¥Î≥¥ÏÑ∏Ïöî"
            )
            for item in popular
        ]
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ïù∏Í∏∞ ÍøàÌíÄÏù¥ Ï°∞Ìöå Ï§ë Ïò§Î•ò: {str(e)}")

@router.get("/categories")
async def get_dream_categories(db: Session = Depends(get_db)):
    """
    Íøà Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ù Ï°∞Ìöå
    """
    try:
        query = """
        SELECT 
            category_code,
            korean_name,
            english_name,
            emoji,
            description,
            parent_id,
            (SELECT COUNT(*) FROM dream_interpretations WHERE category_id = dc.id) as dream_count
        FROM dream_categories dc
        WHERE is_active = true
        ORDER BY sort_order, korean_name
        """
        
        result = db.execute(text(query))
        categories = result.fetchall()
        
        return [
            {
                "category_code": cat.category_code,
                "korean_name": cat.korean_name,
                "english_name": cat.english_name,
                "emoji": cat.emoji,
                "description": cat.description,
                "parent_id": cat.parent_id,
                "dream_count": cat.dream_count
            }
            for cat in categories
        ]
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ïπ¥ÌÖåÍ≥†Î¶¨ Ï°∞Ìöå Ï§ë Ïò§Î•ò: {str(e)}")

@router.get("/combination/{dream_id}")
async def get_dream_combinations(
    dream_id: int,
    db: Session = Depends(get_db)
):
    """
    ÌäπÏ†ï ÍøàÍ≥º Ï°∞Ìï©ÎêòÎäî ÍøàÎì§ Ï°∞Ìöå
    """
    try:
        # Î®ºÏ†Ä Ìï¥Îãπ ÍøàÏùò ÌÇ§ÏõåÎìú Ï°∞Ìöå
        dream_query = "SELECT keyword FROM dream_interpretations WHERE id = :dream_id"
        dream_result = db.execute(text(dream_query), {"dream_id": dream_id}).fetchone()
        
        if not dream_result:
            raise HTTPException(status_code=404, detail="Ìï¥Îãπ ÍøàÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§")
        
        keyword = dream_result.keyword
        
        # Ï°∞Ìï© Ï†ïÎ≥¥ Ï°∞Ìöå
        combination_query = """
        SELECT 
            combination_name,
            dream_keywords,
            combined_meaning,
            strength_level,
            occurrence_frequency
        FROM dream_combinations 
        WHERE :keyword = ANY(dream_keywords)
        ORDER BY strength_level DESC, occurrence_frequency DESC
        LIMIT 10
        """
        
        result = db.execute(text(combination_query), {"keyword": keyword})
        combinations = result.fetchall()
        
        return [
            DreamCombinationResponse(
                combination_name=combo.combination_name,
                dream_keywords=combo.dream_keywords,
                combined_meaning=combo.combined_meaning,
                strength_level=combo.strength_level,
                occurrence_frequency=combo.occurrence_frequency
            )
            for combo in combinations
        ]
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Íøà Ï°∞Ìï© Ï°∞Ìöå Ï§ë Ïò§Î•ò: {str(e)}")

# ====================================
# üåô ÏÇ¨Ïö©Ïûê Íøà Í∏∞Î°ù Í¥ÄÎ¶¨
# ====================================

@router.post("/record")
async def record_user_dream(
    dream_record: UserDreamRecord,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """
    ÏÇ¨Ïö©Ïûê Íøà Í∏∞Î°ù Ï†ÄÏû•
    """
    try:
        # Ìï¥Îãπ ÌÇ§ÏõåÎìúÎì§Ïùò Ìï¥ÏÑù ID Ï∞æÍ∏∞
        interpretation_query = """
        SELECT id FROM dream_interpretations 
        WHERE keyword = ANY(:keywords) OR keyword_variants && :keywords
        """
        
        result = db.execute(text(interpretation_query), {"keywords": dream_record.dream_keywords})
        interpretation_ids = [row.id for row in result.fetchall()]
        
        # ÏÇ¨Ïö©Ïûê Íøà Í∏∞Î°ù Ï†ÄÏû•
        insert_query = """
        INSERT INTO user_dreams 
        (user_id, dream_date, dream_keywords, dream_description, dream_mood, interpretation_ids)
        VALUES (:user_id, :dream_date, :dream_keywords, :dream_description, :dream_mood, :interpretation_ids)
        RETURNING id
        """
        
        dream_id_result = db.execute(text(insert_query), {
            "user_id": current_user.id,
            "dream_date": dream_record.dream_date,
            "dream_keywords": dream_record.dream_keywords,
            "dream_description": dream_record.dream_description,
            "dream_mood": dream_record.dream_mood,
            "interpretation_ids": interpretation_ids
        })
        
        db.commit()
        
        dream_id = dream_id_result.fetchone().id
        return {"message": "Íøà Í∏∞Î°ùÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§", "dream_id": dream_id}
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Íøà Í∏∞Î°ù Ï†ÄÏû• Ï§ë Ïò§Î•ò: {str(e)}")

@router.get("/my-dreams")
async def get_user_dreams(
    limit: int = Query(20, le=100),
    offset: int = Query(0, ge=0),
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """
    ÏÇ¨Ïö©ÏûêÏùò Íøà Í∏∞Î°ù Ï°∞Ìöå
    """
    try:
        query = """
        SELECT 
            id,
            dream_date,
            dream_keywords,
            dream_description,
            dream_mood,
            personal_notes,
            user_rating,
            came_true,
            created_at
        FROM user_dreams
        WHERE user_id = :user_id
        ORDER BY dream_date DESC, created_at DESC
        LIMIT :limit OFFSET :offset
        """
        
        result = db.execute(text(query), {
            "user_id": current_user.id,
            "limit": limit,
            "offset": offset
        })
        
        dreams = result.fetchall()
        
        return [
            {
                "id": dream.id,
                "dream_date": dream.dream_date,
                "dream_keywords": dream.dream_keywords,
                "dream_description": dream.dream_description,
                "dream_mood": dream.dream_mood,
                "personal_notes": dream.personal_notes,
                "user_rating": dream.user_rating,
                "came_true": dream.came_true,
                "created_at": dream.created_at
            }
            for dream in dreams
        ]
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Íøà Í∏∞Î°ù Ï°∞Ìöå Ï§ë Ïò§Î•ò: {str(e)}")

# ====================================
# üåô ÌÜµÍ≥Ñ Î∞è Î∂ÑÏÑù ÏóîÎìúÌè¨Ïù∏Ìä∏
# ====================================

@router.get("/stats/trending")
async def get_trending_dreams(
    period_hours: int = Query(24, description="Î∂ÑÏÑù Í∏∞Í∞Ñ (ÏãúÍ∞Ñ)"),
    db: Session = Depends(get_db)
):
    """
    Ìä∏Î†åÎî© ÍøàÌíÄÏù¥ ÌÇ§ÏõåÎìú Î∂ÑÏÑù
    """
    try:
        query = """
        SELECT 
            keyword,
            search_count,
            trend_score,
            (search_count::float / LAG(search_count) OVER (ORDER BY last_searched_at) - 1) * 100 as growth_rate
        FROM dream_search_stats
        WHERE last_searched_at >= NOW() - INTERVAL '%s hours'
        ORDER BY trend_score DESC, search_count DESC
        LIMIT 15
        """ % period_hours
        
        result = db.execute(text(query))
        trending = result.fetchall()
        
        return [
            {
                "keyword": item.keyword,
                "search_count": item.search_count,
                "trend_score": float(item.trend_score),
                "growth_rate": float(item.growth_rate) if item.growth_rate else 0.0
            }
            for item in trending
        ]
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ìä∏Î†åÎî© Î∂ÑÏÑù Ï§ë Ïò§Î•ò: {str(e)}")

@router.get("/stats/quality-report")
async def get_data_quality_report(db: Session = Depends(get_db)):
    """
    ÍøàÌíÄÏù¥ Îç∞Ïù¥ÌÑ∞ ÌíàÏßà Î≥¥Í≥†ÏÑú
    """
    try:
        # Îç∞Ïù¥ÌÑ∞ ÌíàÏßà Ï≤¥ÌÅ¨ Ìï®Ïàò Ìò∏Ï∂ú
        quality_result = db.execute(text("SELECT * FROM check_dream_data_quality()"))
        quality_issues = quality_result.fetchall()
        
        # Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ
        stats_query = """
        SELECT 
            COUNT(*) as total_dreams,
            COUNT(DISTINCT keyword) as unique_keywords,
            AVG(confidence_score) as avg_confidence,
            AVG(accuracy_rating) as avg_accuracy,
            COUNT(*) FILTER (WHERE fortune_aspect = 'positive') as positive_dreams,
            COUNT(*) FILTER (WHERE fortune_aspect = 'negative') as negative_dreams,
            COUNT(*) FILTER (WHERE fortune_aspect = 'neutral') as neutral_dreams
        FROM dream_interpretations
        """
        
        stats_result = db.execute(text(stats_query))
        stats = stats_result.fetchone()
        
        return {
            "total_statistics": {
                "total_dreams": stats.total_dreams,
                "unique_keywords": stats.unique_keywords,
                "avg_confidence": float(stats.avg_confidence) if stats.avg_confidence else 0.0,
                "avg_accuracy": float(stats.avg_accuracy) if stats.avg_accuracy else 0.0,
                "positive_dreams": stats.positive_dreams,
                "negative_dreams": stats.negative_dreams,
                "neutral_dreams": stats.neutral_dreams
            },
            "quality_issues": [
                {
                    "issue_type": issue.issue_type,
                    "affected_count": issue.affected_count,
                    "description": issue.description
                }
                for issue in quality_issues
            ]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"ÌíàÏßà Î≥¥Í≥†ÏÑú ÏÉùÏÑ± Ï§ë Ïò§Î•ò: {str(e)}")

# ====================================
# üåô Ìó¨Ìçº Ìï®ÏàòÎì§
# ====================================

async def update_search_stats(keywords: List[str], db: Session):
    """
    Í≤ÄÏÉâ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ (ÎπÑÎèôÍ∏∞)
    """
    try:
        for keyword in keywords:
            upsert_query = """
            INSERT INTO dream_search_stats (keyword, search_count, last_searched_at)
            VALUES (:keyword, 1, CURRENT_TIMESTAMP)
            ON CONFLICT (keyword) 
            DO UPDATE SET 
                search_count = dream_search_stats.search_count + 1,
                last_searched_at = CURRENT_TIMESTAMP,
                daily_searches = CASE 
                    WHEN DATE(dream_search_stats.last_searched_at) = CURRENT_DATE 
                    THEN dream_search_stats.daily_searches + 1 
                    ELSE 1 
                END
            """
            
            db.execute(text(upsert_query), {"keyword": keyword})
        
        db.commit()
        
    except Exception as e:
        print(f"Í≤ÄÏÉâ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: {str(e)}")
        db.rollback()

# ====================================
# üåô Îç∞Ïù¥ÌÑ∞ ÏàòÏßëÏö© Í¥ÄÎ¶¨Ïûê ÏóîÎìúÌè¨Ïù∏Ìä∏
# ====================================

@router.post("/admin/bulk-import")
async def bulk_import_dreams(
    dreams_data: List[Dict[str, Any]],
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)  # Í¥ÄÎ¶¨Ïûê Í∂åÌïú Ï≤¥ÌÅ¨ ÌïÑÏöî
):
    """
    ÎåÄÎüâ ÍøàÌíÄÏù¥ Îç∞Ïù¥ÌÑ∞ ÏûÑÌè¨Ìä∏
    Í¥ÄÎ¶¨Ïûê Ï†ÑÏö© ÏóîÎìúÌè¨Ïù∏Ìä∏
    """
    try:
        imported_count = 0
        
        for dream_data in dreams_data:
            # Ï§ëÎ≥µ Ï≤¥ÌÅ¨
            existing_query = "SELECT id FROM dream_interpretations WHERE keyword = :keyword"
            existing = db.execute(text(existing_query), {"keyword": dream_data.get("keyword")}).fetchone()
            
            if existing:
                continue  # Ï§ëÎ≥µÏù¥Î©¥ Ïä§ÌÇµ
            
            # Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ
            insert_query = """
            INSERT INTO dream_interpretations 
            (keyword, keyword_variants, category_id, traditional_meaning, modern_meaning, 
             psychological_meaning, fortune_aspect, confidence_score, related_keywords, 
             lucky_numbers, data_source, created_by)
            VALUES 
            (:keyword, :keyword_variants, :category_id, :traditional_meaning, :modern_meaning,
             :psychological_meaning, :fortune_aspect, :confidence_score, :related_keywords,
             :lucky_numbers, :data_source, :created_by)
            """
            
            db.execute(text(insert_query), {
                **dream_data,
                "created_by": current_user.username
            })
            
            imported_count += 1
        
        db.commit()
        
        return {
            "message": f"{imported_count}Í∞úÏùò ÍøàÌíÄÏù¥ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏûÑÌè¨Ìä∏ÎêòÏóàÏäµÎãàÎã§",
            "imported_count": imported_count,
            "total_submitted": len(dreams_data)
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Îç∞Ïù¥ÌÑ∞ ÏûÑÌè¨Ìä∏ Ï§ë Ïò§Î•ò: {str(e)}")

# ====================================
# üåç Îã§Í∞ÅÎèÑ Ìï¥ÏÑù ÏóîÎìúÌè¨Ïù∏Ìä∏
# ====================================

@router.get("/multi-perspective/search", response_model=Dict[str, Any])
async def search_multi_perspective_dreams(
    q: str = Query(..., description="Í≤ÄÏÉâ ÌÇ§ÏõåÎìú"),
    limit: int = Query(20, le=50, description="ÏµúÎåÄ Í≤∞Í≥º Ïàò"),
    db: Session = Depends(get_db)
):
    """
    Îã§Í∞ÅÎèÑ Ìï¥ÏÑùÏù¥ Í∞ÄÎä•Ìïú ÍøàÌíÄÏù¥ Í≤ÄÏÉâ
    """
    try:
        # Í∏∞Î≥∏ Í≤ÄÏÉâ ÏøºÎ¶¨ - Îã§Í∞ÅÎèÑ Ìï¥ÏÑùÏù¥ ÏûàÎäî ÍøàÎßå Í≤ÄÏÉâ
        search_query = """
        WITH dream_perspective_counts AS (
            SELECT 
                di.id,
                di.keyword,
                di.emoji,
                COUNT(dpi.perspective_id) as perspective_count,
                ARRAY_AGG(ip.perspective_name) as available_perspectives
            FROM dream_interpretations di
            INNER JOIN dream_perspective_interpretations dpi ON di.id = dpi.dream_id
            INNER JOIN interpretation_perspectives ip ON dpi.perspective_id = ip.id
            WHERE 
                (di.keyword ILIKE :search_term OR 
                 :plain_search = ANY(di.keyword_variants) OR
                 to_tsvector('korean', di.traditional_meaning || ' ' || di.modern_meaning) @@ plainto_tsquery('korean', :plain_search))
            GROUP BY di.id, di.keyword, di.emoji
            HAVING COUNT(dpi.perspective_id) >= 2
        )
        SELECT * FROM dream_perspective_counts
        ORDER BY perspective_count DESC, keyword ASC
        LIMIT :limit
        """
        
        params = {
            "search_term": f"%{q}%",
            "plain_search": q,
            "limit": limit
        }
        
        result = db.execute(text(search_query), params)
        dreams = result.fetchall()
        
        search_results = [
            MultiPerspectiveSearchResult(
                id=str(dream.id),
                keyword=dream.keyword,
                emoji=dream.emoji or "üí≠",
                perspective_count=dream.perspective_count,
                available_perspectives=dream.available_perspectives or []
            )
            for dream in dreams
        ]
        
        return {
            "results": search_results,
            "total": len(search_results),
            "query": q
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Îã§Í∞ÅÎèÑ Ìï¥ÏÑù Í≤ÄÏÉâ Ï§ë Ïò§Î•ò: {str(e)}")

@router.get("/multi-perspective/{dream_id}", response_model=MultiPerspectiveDreamResponse)
async def get_multi_perspective_dream(
    dream_id: str,
    perspectives: str = Query("", description="ÏöîÏ≤≠Ìï† Í¥ÄÏ†êÎì§ (ÏΩ§ÎßàÎ°ú Íµ¨Î∂Ñ, Îπà Í∞íÏù¥Î©¥ Î™®Îì† Í¥ÄÏ†ê)"),
    db: Session = Depends(get_db)
):
    """
    ÌäπÏ†ï ÍøàÏùò Îã§Í∞ÅÎèÑ Ìï¥ÏÑù Ï°∞Ìöå
    """
    try:
        # Í∏∞Î≥∏ Íøà Ï†ïÎ≥¥ Ï°∞Ìöå
        dream_query = """
        SELECT id, keyword, emoji, traditional_meaning, modern_meaning
        FROM dream_interpretations 
        WHERE id = :dream_id
        """
        
        dream_result = db.execute(text(dream_query), {"dream_id": int(dream_id)})
        dream = dream_result.fetchone()
        
        if not dream:
            raise HTTPException(status_code=404, detail="Íøà Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§")
        
        # ÏöîÏ≤≠Îêú Í¥ÄÏ†êÎì§ ÌååÏã±
        requested_perspectives = []
        if perspectives:
            requested_perspectives = [p.strip() for p in perspectives.split(",") if p.strip()]
        
        # Îã§Í∞ÅÎèÑ Ìï¥ÏÑù Ï°∞Ìöå
        if requested_perspectives:
            perspective_condition = "AND ip.perspective_code = ANY(:perspectives)"
            params = {"dream_id": int(dream_id), "perspectives": requested_perspectives}
        else:
            perspective_condition = ""
            params = {"dream_id": int(dream_id)}
        
        perspective_query = f"""
        SELECT 
            ip.perspective_code,
            ip.perspective_name,
            ip.description as cultural_context,
            dpi.interpretation,
            dpi.confidence_score,
            dpi.source_quality,
            dpi.tags,
            dpi.cultural_context as additional_context
        FROM dream_perspective_interpretations dpi
        INNER JOIN interpretation_perspectives ip ON dpi.perspective_id = ip.id
        WHERE dpi.dream_id = :dream_id {perspective_condition}
        ORDER BY ip.display_order, dpi.confidence_score DESC
        """
        
        perspective_result = db.execute(text(perspective_query), params)
        perspective_data = perspective_result.fetchall()
        
        if not perspective_data:
            raise HTTPException(status_code=404, detail="Ìï¥Îãπ ÍøàÏùò Îã§Í∞ÅÎèÑ Ìï¥ÏÑùÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§")
        
        # Í¥ÄÏ†êÎ≥Ñ Ìï¥ÏÑù Îç∞Ïù¥ÌÑ∞ Íµ¨ÏÑ±
        perspectives_dict = {}
        for p in perspective_data:
            perspectives_dict[p.perspective_code] = PerspectiveInterpretation(
                perspective_id=p.perspective_code,
                perspective_name=p.perspective_name,
                interpretation=p.interpretation,
                cultural_context=p.additional_context or p.cultural_context,
                confidence_score=p.confidence_score,
                source_quality=p.source_quality,
                tags=p.tags or []
            )
        
        # ÎπÑÍµê Î∂ÑÏÑù Ï°∞Ìöå
        comparison_query = """
        SELECT 
            common_themes,
            conflicting_views,
            cultural_differences,
            recommended_interpretation
        FROM dream_comparison_analysis
        WHERE dream_id = :dream_id
        LIMIT 1
        """
        
        comparison_result = db.execute(text(comparison_query), {"dream_id": int(dream_id)})
        comparison_data = comparison_result.fetchone()
        
        # Í∏∞Î≥∏ Î∂ÑÏÑùÏù¥ ÏóÜÏúºÎ©¥ ÏûêÎèô ÏÉùÏÑ±
        if not comparison_data:
            comparison_analysis = await generate_comparison_analysis(dream_id, perspectives_dict, db)
        else:
            comparison_analysis = ComparisonAnalysis(
                common_themes=comparison_data.common_themes or [],
                conflicting_views=comparison_data.conflicting_views or [],
                cultural_differences=comparison_data.cultural_differences or [],
                recommended_interpretation=comparison_data.recommended_interpretation or ""
            )
        
        return MultiPerspectiveDreamResponse(
            dream_id=str(dream.id),
            keyword=dream.keyword,
            emoji=dream.emoji or "üí≠",
            perspectives=perspectives_dict,
            comparison_analysis=comparison_analysis
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Îã§Í∞ÅÎèÑ Ìï¥ÏÑù Ï°∞Ìöå Ï§ë Ïò§Î•ò: {str(e)}")

# ====================================
# üß† AI Î∂ÑÏÑù Ìó¨Ìçº Ìï®ÏàòÎì§
# ====================================

async def generate_comparison_analysis(dream_id: str, perspectives: Dict[str, PerspectiveInterpretation], db: Session) -> ComparisonAnalysis:
    """
    Îã§Í∞ÅÎèÑ Ìï¥ÏÑù ÎπÑÍµê Î∂ÑÏÑù ÏûêÎèô ÏÉùÏÑ±
    """
    try:
        # Í∞ÑÎã®Ìïú ÌÇ§ÏõåÎìú Í∏∞Î∞ò Î∂ÑÏÑù (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî AI Î™®Îç∏ ÏÇ¨Ïö©)
        all_interpretations = [p.interpretation for p in perspectives.values()]
        all_tags = []
        for p in perspectives.values():
            all_tags.extend(p.tags)
        
        # Í≥µÌÜµ ÌÇ§ÏõåÎìú Ï∞æÍ∏∞ (Í∞ÑÎã®Ìïú Íµ¨ÌòÑ)
        common_keywords = []
        for interpretation in all_interpretations:
            words = interpretation.lower().split()
            for word in words:
                if len(word) > 2 and all_interpretations.count(word) >= 2:
                    common_keywords.append(word)
        
        # Î¨∏ÌôîÏ†Å Ï∞®Ïù¥ Î∂ÑÏÑù (Í¥ÄÏ†ê Ïù¥Î¶Ñ Í∏∞Î∞ò)
        cultural_differences = []
        perspective_names = list(perspectives.keys())
        if 'korean_traditional' in perspective_names and 'western_psychology' in perspective_names:
            cultural_differences.append("ÎèôÏñëÏ†Å ÏÉÅÏßï Ìï¥ÏÑù vs ÏÑúÍµ¨Ï†Å Ïã¨Î¶¨ Î∂ÑÏÑù")
        if 'chinese_traditional' in perspective_names and 'islamic' in perspective_names:
            cultural_differences.append("Ïú†ÍµêÏ†Å Ìï¥ÏÑù vs Ïù¥Ïä¨ÎûåÏ†Å Ìï¥ÏÑù")
        
        # Ï∂îÏ≤ú Ìï¥ÏÑù ÏÉùÏÑ± (Í∞ÄÏû• ÎÜíÏùÄ Ïã†Î¢∞ÎèÑ)
        best_perspective = max(perspectives.values(), key=lambda p: p.confidence_score)
        recommended = f"{best_perspective.perspective_name} Í¥ÄÏ†êÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Ìïú Ìï¥ÏÑùÏùÑ Ï∂îÏ≤úÌï©ÎãàÎã§: {best_perspective.interpretation[:100]}..."
        
        comparison_analysis = ComparisonAnalysis(
            common_themes=list(set(common_keywords))[:5],
            conflicting_views=["Ìï¥ÏÑù Î∞©Î≤ïÎ°†Ïùò Ï∞®Ïù¥", "Î¨∏ÌôîÏ†Å Î∞∞Í≤ΩÏùò Ï∞®Ïù¥"],
            cultural_differences=cultural_differences,
            recommended_interpretation=recommended
        )
        
        # Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•
        save_query = """
        INSERT INTO dream_comparison_analysis 
        (dream_id, common_themes, conflicting_views, cultural_differences, recommended_interpretation, created_at)
        VALUES (:dream_id, :common_themes, :conflicting_views, :cultural_differences, :recommended_interpretation, NOW())
        ON CONFLICT (dream_id) DO UPDATE SET
            common_themes = EXCLUDED.common_themes,
            conflicting_views = EXCLUDED.conflicting_views,
            cultural_differences = EXCLUDED.cultural_differences,
            recommended_interpretation = EXCLUDED.recommended_interpretation,
            updated_at = NOW()
        """
        
        db.execute(text(save_query), {
            "dream_id": int(dream_id),
            "common_themes": comparison_analysis.common_themes,
            "conflicting_views": comparison_analysis.conflicting_views,
            "cultural_differences": comparison_analysis.cultural_differences,
            "recommended_interpretation": comparison_analysis.recommended_interpretation
        })
        db.commit()
        
        return comparison_analysis
        
    except Exception as e:
        print(f"ÎπÑÍµê Î∂ÑÏÑù ÏÉùÏÑ± Ï§ë Ïò§Î•ò: {str(e)}")
        # Í∏∞Î≥∏Í∞í Î∞òÌôò
        return ComparisonAnalysis(
            common_themes=["ÏÑ±Ïû•", "Î≥ÄÌôî", "Í∏∞Ìöå"],
            conflicting_views=["Ìï¥ÏÑù Í¥ÄÏ†êÏùò Ï∞®Ïù¥"],
            cultural_differences=["ÎèôÏÑúÏñë Ìï¥ÏÑùÏùò Ï∞®Ïù¥"],
            recommended_interpretation="Ï¢ÖÌï©Ï†ÅÏù∏ Í¥ÄÏ†êÏóêÏÑú Í∏çÏ†ïÏ†ÅÏù∏ ÏùòÎØ∏Î°ú Ìï¥ÏÑùÌïòÏãúÍ∏∏ Í∂åÌï©ÎãàÎã§."
        )