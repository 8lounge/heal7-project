// 운세 캘린더 데이터 시스템 - KASI API 연동 + Atomic 모듈 통합
// ======================================================================
// 🔥 만세력 핵심 상수 기준값 (CRITICAL CONSTANTS) 🔥
// ======================================================================

// 🔥 중복 제거: 상수는 sajuConstants.ts에서 import
import { 갑자60순환, 갑자한자매핑, get갑자표시 } from './sajuConstants';
import { 
  get절기, get절기상세정보, is절기날, get절기운세보정, 절기아이콘매핑,
  get운세점수, get특이사항, get길흉, is손없는날 
} from './calendarUtils';

// 🚀 Atomic API 전환 설정 (점진적 마이그레이션)
export const ATOMIC_API_CONFIG = {
  /** 
   * 🔥 Atomic API 사용 여부 (기본값: false - 기존 시스템 유지)
   * ⚠️  true로 설정 시 모든 계산이 백엔드 atomic 모듈로 이동
   * 📈 성능: 프론트엔드 로직 제거, 서버 중앙화
   */
  USE_ATOMIC_API: false, // 개발 단계에서는 false로 시작
  
  /** 
   * 🎯 부분적 전환 설정 (특정 기능만 atomic 사용)
   */
  ATOMIC_FEATURES: {
    GAPJA_CALCULATION: true,   // 60갑자 계산을 atomic으로
    YEAR_PILLAR: true,         // 년주 계산을 atomic으로
    LUNAR_CONVERSION: false,   // 음력 변환은 아직 기존 시스템
    COMPLETE_SAJU: false,      // 완전한 사주는 아직 기존 시스템
  },
  
  /** 
   * 🔧 폴백 설정 (atomic API 실패 시 기존 로직 사용)
   */
  ENABLE_FALLBACK: true,
  
  /** 
   * 📊 성능 모니터링 (atomic vs 기존 로직 비교)
   */
  ENABLE_PERFORMANCE_MONITORING: true,
} as const;

// 🎯 1. 60갑자 계산 핵심 기준점 (절대 변경 금지)
export const GAPJA_REFERENCE_CONSTANTS = {
  /** 
   * 🔥 60갑자 절대 기준일: 1900년 1월 31일 = 갑진일
   * ⚠️  이 값을 변경하면 모든 만세력 계산이 틀어짐
   * 📚 출처: 전통 명리학 표준, KASI API 호환
   */
  REFERENCE_DATE: new Date(1900, 0, 31), // 1900년 1월 31일
  REFERENCE_GAPJA: '갑진',
  REFERENCE_GAPJA_INDEX: 40, // 갑자60순환 배열에서의 위치
  
  /** 
   * 🔥 입춘 기준 (연주 계산의 핵심)
   * ⚠️  매년 2월 4일 전후가 입춘이며, 이 기준으로 연주가 바뀜
   */
  SPRING_START_MONTH: 2,
  SPRING_START_DAY: 4,
} as const;

// 🎯 2. 진태양시 계산 상수 (국가별 지역 기준)
export const SOLAR_TIME_CONSTANTS = {
  /** 
   * 🔥 한국(서울) 기준 진태양시 보정
   * 위도: 37.5665°N, 경도: 126.9780°E (서울 중심)
   * 표준 경도: 135°E (동경 135도 - 한국표준시)
   * 보정값: (126.978 - 135) × 4분/도 = -32.09분 ≈ -32분
   */
  KOREA_LONGITUDE: 126.978,
  KOREA_STANDARD_LONGITUDE: 135.0,
  KOREA_TIME_CORRECTION_MINUTES: -32, // 서울 표준시 기준 경도차 보정
  
  /** 
   * 🔥 다른 국가 확장용 (향후 글로벌 서비스 대비)
   */
  CHINA_LONGITUDE: 116.4074, // 베이징
  CHINA_TIME_CORRECTION_MINUTES: -46,
  JAPAN_LONGITUDE: 139.6917, // 도쿄  
  JAPAN_TIME_CORRECTION_MINUTES: 19,
} as const;

// 🎯 3. 24절기 및 계절 기준 상수
export const SEASONAL_CONSTANTS = {
  /** 
   * 🔥 24절기 기준 (월주 계산의 핵심)
   * ⚠️  KASI API 기준이지만 표준시 → 진태양시 보정 필요
   * 📌 KASI는 표준시(KST) 기준이므로 진태양시 적용시 -32분 보정 적용
   */
  SOLAR_TERMS_REFERENCE: {
    1: { term: '입춘', approx_date: [2, 4], kasi_time_offset: -32 }, // 2월 4일 전후, 진태양시 -32분
    2: { term: '경칩', approx_date: [3, 5], kasi_time_offset: -32 },
    3: { term: '청명', approx_date: [4, 5], kasi_time_offset: -32 },  
    4: { term: '입하', approx_date: [5, 5], kasi_time_offset: -32 },
    5: { term: '망종', approx_date: [6, 6], kasi_time_offset: -32 },
    6: { term: '소서', approx_date: [7, 7], kasi_time_offset: -32 },
    7: { term: '입추', approx_date: [8, 7], kasi_time_offset: -32 },
    8: { term: '백로', approx_date: [9, 8], kasi_time_offset: -32 },
    9: { term: '한로', approx_date: [10, 8], kasi_time_offset: -32 },
    10: { term: '입동', approx_date: [11, 7], kasi_time_offset: -32 },
    11: { term: '대설', approx_date: [12, 7], kasi_time_offset: -32 },
    12: { term: '소한', approx_date: [1, 5], kasi_time_offset: -32 }, // 다음해 1월
  },
  
  /** 
   * 🔥 KASI API vs 진태양시 보정 상수
   * ⚠️  KASI API는 KST(한국표준시) 기준으로 절기를 제공
   * 📌 진태양시 사주계산에서는 이 보정값을 적용해야 정확함
   */
  KASI_TO_TRUE_SOLAR_CORRECTION: {
    KOREA_KST_OFFSET_MINUTES: -32, // 서울 기준 진태양시 보정
    DST_ADJUSTMENT_NEEDED: false, // 한국은 서머타임 없음
    PRECISION_THRESHOLD_HOURS: 2, // 절기 전후 2시간 내에서는 정밀 계산 필요
  },
  
  /** 
   * 🔥 월지지 매핑 (절기 기준)
   * ⚠️  입춘부터 시작하여 12개월 순환
   */
  MONTH_JIJI_MAP: {
    1: '寅', 2: '卯', 3: '辰', 4: '巳', 5: '午', 6: '未',
    7: '申', 8: '酉', 9: '戌', 10: '亥', 11: '子', 12: '丑'
  },
  
  /** 
   * 🔥 음력 + 절기 비교대조 계산 원칙 (2025-09-04 신규 반영)
   * ⚠️  월주, 일주 계산의 정확성을 위한 핵심 원칙
   * 📌 양력 계산 대비 복잡도 감소 및 정확도 향상
   */
  LUNAR_SOLAR_TERMS_PRINCIPLE: {
    /** 월주 계산 방식: 음력 월 + 해당 절기 확인 */
    MONTH_PILLAR_METHOD: '음력_절기_비교대조',
    
    /** 일주 계산 방식: 음력 날짜 기준 60갑자 순환 */
    DAY_PILLAR_METHOD: '음력_60갑자_순환',
    
    /** 계산 복잡도 감소: 양력 → 음력 변환 후 계산 */
    COMPLEXITY_REDUCTION: true,
    
    /** 정확도 보장: 전통 명리학 표준 준수 */
    TRADITIONAL_ACCURACY: true,
    
    /** 
     * 🔥 핵심 계산 순서 (반드시 준수)
     * 1. 양력 출생일 → KASI API → 음력 변환
     * 2. 음력 기준으로 해당 절기 확인
     * 3. 절기와 음력 월 비교대조하여 월주 결정
     * 4. 음력 일자로 60갑자 순환 계산하여 일주 결정
     */
    CALCULATION_ORDER: [
      'solar_to_lunar_conversion',
      'solar_term_identification', 
      'lunar_month_solar_term_comparison',
      'month_pillar_determination',
      'lunar_date_60gapja_calculation',
      'day_pillar_determination'
    ],
  },
} as const;

// 🎯 4. 서머타임 및 시간대 상수
export const TIMEZONE_CONSTANTS = {
  /** 
   * 🔥 한국은 서머타임 없음 (연중 UTC+9 고정)
   * ⚠️  따라서 KASI API도 서머타임 고려 불필요
   */
  KOREA_USES_DST: false,
  KOREA_UTC_OFFSET: 9,
  
  /** 
   * 🔥 서머타임 적용 국가들 (향후 확장용)
   * ⚠️  이들 국가에서는 KASI 대응 API의 절기 시간도 DST 보정 필요
   */
  DST_COUNTRIES: {
    'US': { 
      start: [3, 2, 0], end: [11, 1, 0], // 3월 2주 일요일 ~ 11월 1주 일요일
      standard_offset: -5, // EST UTC-5
      dst_offset: -4, // EDT UTC-4
      solar_time_correction_needed: true
    },
    'EU': { 
      start: [3, -1, 0], end: [10, -1, 0], // 3월 마지막 일요일 ~ 10월 마지막 일요일  
      standard_offset: 1, // CET UTC+1
      dst_offset: 2, // CEST UTC+2
      solar_time_correction_needed: true
    },
  },
  
  /** 
   * 🔥 시간대별 KASI 대응 API 정보 (향후 글로벌 서비스용)
   * ⚠️  각 국가의 천문 API는 해당 지역 표준시 기준이므로 진태양시 보정 필수
   */
  GLOBAL_ASTRONOMICAL_APIS: {
    'KOREA': { source: 'KASI', timezone: 'KST', needs_solar_correction: true },
    'CHINA': { source: 'CAS', timezone: 'CST', needs_solar_correction: true },
    'JAPAN': { source: 'NAOJ', timezone: 'JST', needs_solar_correction: true },
    'US': { source: 'USNO', timezone: 'multiple', needs_dst_handling: true },
  },
} as const;

// 🎯 5. 시주 계산 핵심 상수
export const HOUR_CONSTANTS = {
  /** 
   * 🔥 시두법 매핑 (일간에 따른 시천간 결정)
   * ⚠️  이 매핑이 시주 계산의 핵심
   */
  HOUR_CHEONGAN_BY_DAY: {
    '甲': ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸', '甲', '乙'],
    '乙': ['丙', '丁', '戊', '己', '庚', '辛', '壬', '癸', '甲', '乙', '丙', '丁'],
    '丙': ['戊', '己', '庚', '辛', '壬', '癸', '甲', '乙', '丙', '丁', '戊', '己'],
    '丁': ['庚', '辛', '壬', '癸', '甲', '乙', '丙', '丁', '戊', '己', '庚', '辛'],
    '戊': ['壬', '癸', '甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸'],
    '己': ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸', '甲', '乙'],
    '庚': ['丙', '丁', '戊', '己', '庚', '辛', '壬', '癸', '甲', '乙', '丙', '丁'],
    '辛': ['戊', '己', '庚', '辛', '壬', '癸', '甲', '乙', '丙', '丁', '戊', '己'],
    '壬': ['庚', '辛', '壬', '癸', '甲', '乙', '丙', '丁', '戊', '己', '庚', '辛'],
    '癸': ['壬', '癸', '甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸'],
  },
  
  /** 
   * 🔥 시지지 매핑 (2시간 단위)
   * 23:00-01:00=자, 01:00-03:00=축, ... 순서
   */
  HOUR_JIJI_BOUNDARIES: [23, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23],
} as const;

export interface CalendarDate {
  date: Date;
  lunarDate: string;
  lunarYear: number;
  lunarMonth: number;
  lunarDay: number;
  isLeapMonth: boolean; // 윤달 여부
  gapja: string;
  zodiac: string;
  element: string;
  sonEobNeunNal: boolean; // 손없는날
  gilil: boolean; // 길일
  흉일: boolean; // 흉일
  절기: string | null;
  운세점수: number; // 1-5
  특이사항: string[];
  solarCalendarType: 'solar'; // 양력 표기
  yearPillar?: string; // 연주
  monthPillar?: string; // 월주
}

export interface MonthlyFortune {
  month: number;
  year: number;
  bestDates: CalendarDate[];
  worstDates: CalendarDate[];
  importantDates: CalendarDate[];
  monthlyMessage: string;
}

// 천간 데이터
export const 천간 = ['갑', '을', '병', '정', '무', '기', '경', '신', '임', '계'];
export const 지지 = ['자', '축', '인', '묘', '진', '사', '오', '미', '신', '유', '술', '해'];

// 12지신 동물 매핑
export const 띠동물: Record<string, string> = {
  '자': '쥐', '축': '소', '인': '호랑이', '묘': '토끼', 
  '진': '용', '사': '뱀', '오': '말', '미': '양',
  '신': '원숭이', '유': '닭', '술': '개', '해': '돼지'
};

// 오행 매핑
export const 오행매핑: Record<string, string> = {
  '갑': '목', '을': '목', '병': '화', '정': '화', '무': '토',
  '기': '토', '경': '금', '신': '금', '임': '수', '계': '수'
};

// 🔥 중복 제거: 60갑자 배열은 sajuConstants.ts에서 import됨

// 🔥 중복 제거: 갑자한자매핑과 get갑자표시 함수는 sajuConstants.ts에서 import됨

// 🚀 Atomic API 통합 (동적 import로 번들 크기 최적화)
let atomicAPIModule: any = null;

async function getAtomicAPI() {
  if (!atomicAPIModule) {
    try {
      atomicAPIModule = await import('../utils/atomicSajuAPI');
    } catch (error) {
      console.warn('Atomic API 모듈 로드 실패:', error);
      return null;
    }
  }
  return atomicAPIModule;
}

// 🎯 성능 모니터링을 위한 유틸리티
interface PerformanceMetric {
  method: 'local' | 'atomic';
  duration: number;
  success: boolean;
  timestamp: number;
}

const performanceMetrics: PerformanceMetric[] = [];

function recordPerformance(method: 'local' | 'atomic', duration: number, success: boolean) {
  if (ATOMIC_API_CONFIG.ENABLE_PERFORMANCE_MONITORING) {
    performanceMetrics.push({
      method,
      duration,
      success,
      timestamp: Date.now()
    });
    
    // 최근 100개 기록만 유지
    if (performanceMetrics.length > 100) {
      performanceMetrics.splice(0, 50);
    }
  }
}

export function getPerformanceMetrics() {
  return [...performanceMetrics];
}

// 🔥 로컬 60갑자 계산 함수 (기존 로직 유지)
const get60갑자Local = (date: Date): string => {
  const 기준일 = GAPJA_REFERENCE_CONSTANTS.REFERENCE_DATE;
  const 기준갑자인덱스 = GAPJA_REFERENCE_CONSTANTS.REFERENCE_GAPJA_INDEX;
  
  const 날짜차이 = Math.floor((date.getTime() - 기준일.getTime()) / (24 * 60 * 60 * 1000));
  let 갑자인덱스 = (기준갑자인덱스 + 날짜차이) % 60;
  
  if (갑자인덱스 < 0) {
    갑자인덱스 += 60;
  }
  
  return 갑자60순환[갑자인덱스];
};

// 🚀 하이브리드 60갑자 계산 함수 (Atomic API + 로컬 계산)
export const get60갑자 = async (date: Date): Promise<string> => {
  const startTime = performance.now();
  
  // Atomic API 사용 여부 확인
  if (ATOMIC_API_CONFIG.ATOMIC_FEATURES.GAPJA_CALCULATION) {
    try {
      const atomicAPI = await getAtomicAPI();
      if (atomicAPI) {
        const result = await atomicAPI.get60갑자Atomic(date);
        const duration = performance.now() - startTime;
        recordPerformance('atomic', duration, result !== '❌오류');
        
        if (result !== '❌오류') {
          console.log(`🚀 Atomic 60갑자: ${date.toISOString().split('T')[0]} = ${result}`);
          return result;
        }
      }
    } catch (error) {
      console.warn('Atomic API 갑자 계산 실패, 로컬로 폴백:', error);
    }
  }
  
  // 폴백 또는 기본 로컬 계산
  if (ATOMIC_API_CONFIG.ENABLE_FALLBACK || !ATOMIC_API_CONFIG.ATOMIC_FEATURES.GAPJA_CALCULATION) {
    const result = get60갑자Local(date);
    const duration = performance.now() - startTime;
    recordPerformance('local', duration, true);
    
    // 🔍 9월 5-6일 디버깅 로그 (로컬 계산시에만)
    if (date.getMonth() === 8 && (date.getDate() === 5 || date.getDate() === 6)) {
      console.log(`🔍 로컬 60갑자 계산 (9월 ${date.getDate()}일): ${result}`);
    }
    
    return result;
  }
  
  return '❌오류';
};

// 🔄 동기 버전 (기존 코드 호환성)
export const get60갑자Sync = (date: Date): string => {
  return get60갑자Local(date);
};

// 크로스체크 함수 (검증용) - 60갑자에 실제 존재하는지 확인
export const is유효한60갑자 = (gapja: string): boolean => {
  return 갑자60순환.includes(gapja);
};

// 레거시 방식과 비교 검증 함수 (개발/디버깅용)
export const get60갑자WithValidation = (date: Date): { result: string; isValid: boolean; legacy: string } => {
  // 새로운 배열 기반 방식
  const 새로운결과 = get60갑자Sync(date);
  
  // 레거시 방식 (천간/지지 개별 계산)
  const 기준일 = new Date(1900, 0, 1);
  const 날짜차이 = Math.floor((date.getTime() - 기준일.getTime()) / (24 * 60 * 60 * 1000));
  let 갑자인덱스 = (40 + 날짜차이) % 60;
  if (갑자인덱스 < 0) 갑자인덱스 += 60;
  
  const 천간인덱스 = 갑자인덱스 % 10;
  const 지지인덱스 = 갑자인덱스 % 12;
  const 레거시결과 = 천간[천간인덱스] + 지지[지지인덱스];
  
  return {
    result: 새로운결과,
    isValid: is유효한60갑자(레거시결과),
    legacy: 레거시결과
  };
};

// 🔥 입춘 기준 년주 계산 함수 (60갑자 기준)
export const get년주 = (date: Date): string => {
  const year = date.getFullYear();
  const month = date.getMonth() + 1; // 1-12월
  const day = date.getDate();
  
  // 🔥 입춘 기준: 매년 2월 4일 전후 (KASI 기준)
  // 입춘 이전은 전년도 년주, 입춘 이후는 당년도 년주
  let sajuYear = year;
  if (month < 2 || (month === 2 && day < 4)) {
    sajuYear = year - 1; // 입춘 이전은 전년도
  }
  
  // 🎯 1900년 = 경자년(36번째) 기준으로 60갑자 순환 계산
  const 기준년도 = 1900;
  const 기준년갑자인덱스 = 36; // 경자 = 갑자60순환 배열에서 36번째
  
  let 년갑자인덱스 = (기준년갑자인덱스 + (sajuYear - 기준년도)) % 60;
  if (년갑자인덱스 < 0) 년갑자인덱스 += 60;
  
  const 년주 = 갑자60순환[년갑자인덱스];
  
  // 🔍 2025년 검증 로그
  if (year === 2025) {
    console.log(`🔥 년주 계산 (${year}-${month}-${day}):`, {
      입력날짜: `${year}년 ${month}월 ${day}일`,
      사주기준년도: sajuYear,
      입춘기준적용: month < 2 || (month === 2 && day < 4) ? '전년도' : '당년도',
      계산된인덱스: 년갑자인덱스,
      최종년주: 년주
    });
  }
  
  return 년주;
};

// 정밀 음력 변환 함수 (2025년 정확한 음력 대조표 기준)
export const get음력변환 = (date: Date): string => {
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  
  // 🔥 2025년 정확한 음력-양력 대조표 (한국천문연구원 기준)
  const 정확한음력표 = {
    2025: [
      // [양력월, 양력일, 음력월, 음력일, 윤달여부] 형태
      [1, 29, 1, 1, false],   // 설날
      [2, 12, 1, 15, false],  // 정월대보름
      [2, 27, 1, 30, false],  // 1월 그믐
      [2, 28, 2, 1, false],   // 음력 2월 1일
      [3, 14, 2, 15, false],  // 음력 2월 15일
      [3, 29, 3, 1, false],   // 음력 3월 1일
      [4, 12, 3, 15, false],  // 음력 3월 15일
      [4, 27, 4, 1, false],   // 음력 4월 1일
      [5, 12, 4, 15, false],  // 부처님오신날
      [5, 26, 5, 1, false],   // 음력 5월 1일
      [6, 10, 5, 15, false],  // 음력 5월 15일
      [6, 24, 6, 1, false],   // 음력 6월 1일 
      [7, 9, 6, 15, false],   // 음력 6월 15일
      [7, 23, 7, 1, false],   // 음력 7월 1일
      [8, 7, 7, 15, false],   // 중원절 (칠월칠석)
      [8, 21, 8, 1, false],   // 음력 8월 1일
      [9, 5, 8, 15, false],   // 추석 (중추절)
      [9, 19, 9, 1, false],   // 음력 9월 1일
      [10, 4, 9, 15, false],  // 음력 9월 15일
      [10, 18, 10, 1, false], // 음력 10월 1일
      [11, 2, 10, 15, false], // 음력 10월 15일
      [11, 16, 11, 1, false], // 음력 11월 1일
      [11, 30, 11, 15, false],// 음력 11월 15일
      [12, 15, 12, 1, false], // 음력 12월 1일
      [12, 30, 12, 16, false] // 음력 12월 16일 (연말)
    ]
  };
  
  const 기준점들 = 정확한음력표[year];
  if (!기준점들) {
    return `음력 ${month}월 ${day}일 (근사)`; // 기본값
  }
  
  // 가장 가까운 기준점 찾기
  let 가장가까운기준 = 기준점들[0];
  let 최소차이 = Math.abs((month - 가장가까운기준[0]) * 31 + (day - 가장가까운기준[1]));
  
  for (const 기준점 of 기준점들) {
    const 차이 = Math.abs((month - 기준점[0]) * 31 + (day - 기준점[1]));
    if (차이 < 최소차이) {
      최소차이 = 차이;
      가장가까운기준 = 기준점;
    }
  }
  
  // 기준점으로부터 음력 날짜 추정
  const 양력기준일 = 가장가까운기준[0] * 31 + 가장가까운기준[1];
  const 현재양력일 = month * 31 + day;
  const 일수차이 = 현재양력일 - 양력기준일;
  
  let 음력월 = 가장가까운기준[2];
  let 음력일 = 가장가까운기준[3] + 일수차이;
  
  // 월 경계 처리 (29일/30일 기준)
  while (음력일 > 30) {
    음력일 -= 29; // 평균 음력월 길이
    음력월++;
  }
  while (음력일 < 1) {
    음력일 += 29;
    음력월--;
  }
  
  // 연도 경계 처리
  if (음력월 > 12) {
    음력월 = 음력월 % 12 || 12;
  }
  if (음력월 < 1) {
    음력월 = 12 + 음력월;
  }
  
  return `음력 ${음력월}월 ${음력일}일`;
};

// 🔥 이동됨: calendarUtils.ts에서 import

// 🔥 이동됨: calendarUtils.ts에서 import

// 🔥 이동됨: calendarUtils.ts에서 import

// 🔥 동적 24절기 데이터 시스템 (KASI API 기반)
interface SolarTermData {
  이름: string;
  날짜: Date;
  icon: string;
  color: string; 
  description: string;
  season: string;
}

// 메모리 캐시: 2년치 24절기 데이터 저장
let cachedSolarTerms: Record<number, SolarTermData[]> = {};
let cacheTimestamp: number = 0;
const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24시간 캐시

// 🔥 KASI API를 통한 2년치 24절기 프리로드
export const preloadSolarTermsData = async (): Promise<boolean> => {
  try {
    const now = Date.now();
    const currentYear = new Date().getFullYear();
    
    // 캐시가 유효한 경우 스킵
    if (cacheTimestamp > 0 && (now - cacheTimestamp) < CACHE_DURATION && 
        cachedSolarTerms[currentYear] && cachedSolarTerms[currentYear + 1]) {
      console.log('✅ 24절기 캐시 유효 - 로드 스킵');
      return true;
    }
    
    console.log('🔮 2년치 24절기 데이터 프리로드 시작...');
    
    // 백엔드 KASI API 호출
    const response = await fetch('/api/kasi/solar-terms/preload');
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const result = await response.json();
    
    if (!result.success || !result.data) {
      throw new Error(result.error || '24절기 데이터 로드 실패');
    }
    
    // 캐시에 저장 (아이콘 정보와 함께)
    cachedSolarTerms = {};
    
    for (const [yearStr, termsList] of Object.entries(result.data)) {
      const year = parseInt(yearStr);
      const processedTerms: SolarTermData[] = [];
      
      for (const term of termsList as any[]) {
        const iconInfo = 절기아이콘매핑[term.name];
        
        if (iconInfo) {
          processedTerms.push({
            이름: term.name,
            날짜: new Date(term.date),
            icon: iconInfo.icon,
            color: iconInfo.color,
            description: iconInfo.description,
            season: iconInfo.season
          });
        }
      }
      
      cachedSolarTerms[year] = processedTerms;
    }
    
    cacheTimestamp = now;
    
    console.log(`✅ 2년치 24절기 프리로드 완료: ${result.preload_years.join(', ')}년`);
    console.log(`📊 총 ${result.total_terms}개 절기 로드됨`);
    
    return true;
    
  } catch (error) {
    console.error('❌ 24절기 프리로드 실패:', error);
    return false;
  }
};

// 🔥 연도별 24절기 데이터 조회 (동적)
export const get연도별절기 = async (year: number): Promise<SolarTermData[]> => {
  // 프리로드 시도
  await preloadSolarTermsData();
  
  // 캐시에서 조회
  if (cachedSolarTerms[year]) {
    return cachedSolarTerms[year];
  }
  
  // 캐시 미스 시 개별 조회
  try {
    const response = await fetch(`/api/kasi/solar-terms/${year}`);
    const result = await response.json();
    
    if (result.success && result.solar_terms) {
      const processedTerms: SolarTermData[] = [];
      
      for (const term of result.solar_terms) {
        const iconInfo = 절기아이콘매핑[term.name];
        
        if (iconInfo) {
          processedTerms.push({
            이름: term.name,
            날짜: new Date(term.date),
            icon: iconInfo.icon,
            color: iconInfo.color,
            description: iconInfo.description,
            season: iconInfo.season
          });
        }
      }
      
      // 캐시에 저장
      cachedSolarTerms[year] = processedTerms;
      return processedTerms;
    }
  } catch (error) {
    console.error(`❌ ${year}년 24절기 조회 실패:`, error);
  }
  
  // 폴백: 빈 배열 반환
  console.warn(`⚠️  ${year}년 24절기 데이터 없음 - 빈 배열 반환`);
  return [];
};

// 🔥 앱 시작시 자동 프리로드 (백그라운드 실행)
// 이 함수는 앱이 로드될 때 자동으로 실행됩니다
setTimeout(() => {
  preloadSolarTermsData().then(success => {
    if (success) {
      console.log('🚀 24절기 프리로드 시스템 초기화 완료');
    } else {
      console.warn('⚠️  24절기 프리로드 실패 - 폴백 모드로 동작');
    }
  });
}, 1000); // 1초 후 백그라운드 프리로드

// 🔥 동적 절기 찾기 - KASI API 기반
export const get절기 = (date: Date): string | null => {
  const year = date.getFullYear();
  
  // 캐시된 절기 데이터에서 찾기
  if (cachedSolarTerms[year]) {
    const 해당절기 = cachedSolarTerms[year].find(절기 => {
      const diff = Math.abs(date.getTime() - 절기.날짜.getTime());
      return diff < 24 * 60 * 60 * 1000; // 1일 이내
    });
    return 해당절기?.이름 || null;
  }
  
  // 캐시가 없으면 null 반환 (프리로드 대기 중)
  return null;
};

// 🔥 동적 절기 상세 정보 반환 - KASI API 기반
export const get절기상세정보 = (date: Date): { 
  name: string; 
  icon: string; 
  color: string; 
  description: string; 
  season: string; 
} | null => {
  const year = date.getFullYear();
  
  // 캐시된 절기 데이터에서 직접 찾기
  if (cachedSolarTerms[year]) {
    const 해당절기 = cachedSolarTerms[year].find(절기 => {
      const diff = Math.abs(date.getTime() - 절기.날짜.getTime());
      return diff < 24 * 60 * 60 * 1000; // 1일 이내
    });
    
    if (해당절기) {
      return {
        name: 해당절기.이름,
        icon: 해당절기.icon,
        color: 해당절기.color,
        description: 해당절기.description,
        season: 해당절기.season
      };
    }
  }
  
  // 캐시가 없으면 null 반환
  return null;
};

// 🌟 절기 강조 표시용 함수 (달력에서 절기 날짜 하이라이트)
export const is절기날 = (date: Date): boolean => {
  return get절기(date) !== null;
};

// 🔥 절기 기반 특별한 운세 보정 (절기는 운세 점수에 긍정적 영향)
export const get절기운세보정 = (절기이름: string | null): number => {
  if (!절기이름) return 0;
  
  // 계절별 운세 보정값
  const 계절보정: Record<string, number> = {
    '봄': 1,    // 새로운 시작, 생명력
    '여름': 0.5, // 활기, 성장
    '가을': 1,   // 수확, 결실
    '겨울': 0.5  // 정화, 준비
  };
  
  const 절기정보 = 절기아이콘매핑[절기이름];
  return 절기정보 ? (계절보정[절기정보.season] || 0) : 0;
};

// 운세 점수 계산 (1-5) - 절기 보정 포함
export const get운세점수 = (gapja: string, date: Date): number => {
  const 천간 = gapja[0];
  const 지지 = gapja[1];
  const 오행 = 오행매핑[천간];
  const dayOfWeek = date.getDay();
  const day = date.getDate();
  
  let 점수 = 3; // 기본 점수
  
  // 오행별 요일 보정
  const 오행요일보정: Record<string, number[]> = {
    '목': [1, 4], // 월, 목
    '화': [2], // 화
    '토': [6], // 토
    '금': [5], // 금
    '수': [0, 3] // 일, 수
  };
  
  if (오행요일보정[오행]?.includes(dayOfWeek)) {
    점수 += 1;
  }
  
  // 날짜별 보정
  if (day % 6 === 0) 점수 += 1; // 6의 배수
  if (day === 8 || day === 18 || day === 28) 점수 += 1; // 발음이 좋은 날
  
  // 지지별 보정
  const 지지보정: Record<string, number> = {
    '용': 1, '호랑이': 1, '말': 1, '닭': 1, // 활동적
    '쥐': -1, '뱀': -1 // 조용한
  };
  
  const 띠 = 띠동물[지지];
  if (띠) {
    점수 += 지지보정[띠] || 0;
  }
  
  // 🔥 절기 보정 추가 (절기일은 특별한 날이므로 운세 점수 상승)
  const 절기이름 = get절기(date);
  const 절기보정 = get절기운세보정(절기이름);
  점수 += 절기보정;
  
  return Math.max(1, Math.min(5, 점수));
};

// 특이사항 생성 (윤달 정보 포함)
export const get특이사항 = (date: Date, gapja: string, isLeapMonth?: boolean): string[] => {
  const 특이사항: string[] = [];
  const 천간 = gapja[0];
  const 지지 = gapja[1];
  const 띠 = 띠동물[지지];
  const dayOfWeek = date.getDay();
  
  // 🔥 윤달 정보 최우선 표시
  if (isLeapMonth) {
    특이사항.push('🌙+ 윤달 (음력 특별한 달)');
  }
  
  if (is손없는날(date)) {
    특이사항.push('👻 손없는날');
  }
  
  const { 길일, 흉일 } = get길흉(gapja, date);
  if (길일) 특이사항.push('✨ 길일');
  if (흉일) 특이사항.push('⚠️ 흉일');
  
  const 절기 = get절기(date);
  if (절기) {
    const 절기정보 = get절기상세정보(date);
    if (절기정보) {
      특이사항.push(`${절기정보.icon} ${절기} (${절기정보.description})`);
    } else {
      특이사항.push(`🌸 ${절기}`);
    }
  }
  
  // 특별한 조합
  if (천간 === '갑' && 지지 === '자') {
    특이사항.push('🌟 갑자일 (새로운 시작)');
  }
  
  if (dayOfWeek === 0) {
    특이사항.push('☀️ 일요일 (휴식)');
  }
  
  if (띠 === '용') {
    특이사항.push('🐉 용의 기운 (강운)');
  }
  
  return 특이사항;
};

// ===== KASI API 전용 캘린더 데이터 생성 =====
// 폴백 없음, 오류 발생 시 구체적 표기 및 기록

interface KasiApiError {
  date: Date;
  errorType: 'API_CALL_FAILED' | 'PARSING_FAILED' | 'NETWORK_ERROR' | 'TIMEOUT';
  errorMessage: string;
  timestamp: string;
}

// KASI API 오류 로그 (메모리 저장)
const kasiApiErrors: KasiApiError[] = [];

// 🚀 최적화된 캘린더 데이터 생성 (배치 처리 + 로컬 캐시)
export const generateCalendarMonth = async (year: number, month: number): Promise<CalendarDate[]> => {
  const daysInMonth = new Date(year, month, 0).getDate();
  const calendarDates: CalendarDate[] = [];
  
  console.log(`🔮 최적화된 캘린더 생성 시작: ${year}년 ${month}월 (${daysInMonth}일)`);
  
  // 🔥 최적화된 60갑자 패턴 기반 계산: 단 1개의 기준점만 KASI API 호출
  const referenceDay = 15; // 월 중순 기준점 (안정적)
  let kasiReferenceData = null;
  let gapjaOffset = 0; // KASI 기준점과 로컬 계산간의 오프셋
  
  // 기준점 KASI API 호출
  if (referenceDay <= daysInMonth) {
    try {
      kasiReferenceData = await fetchKasiCalendarInfo(year, month, referenceDay);
      if (kasiReferenceData) {
        // KASI 갑자와 로컬 계산 갑자 비교하여 오프셋 계산
        const referenceDate = new Date(year, month - 1, referenceDay);
        const localGapja = get60갑자Sync(referenceDate);
        const kasiGapja = kasiReferenceData.lunIljin;
        
        // 갑자 배열에서 인덱스 찾기
        const localIndex = 갑자60순환.indexOf(localGapja);
        const kasiIndex = 갑자60순환.indexOf(kasiGapja);
        
        if (localIndex !== -1 && kasiIndex !== -1) {
          gapjaOffset = kasiIndex - localIndex;
          console.log(`🎯 KASI-로컬 갑자 오프셋 계산: ${year}-${month}-${referenceDay}`, {
            localGapja, kasiGapja, localIndex, kasiIndex, gapjaOffset
          });
        } else {
          console.error(`❌ 갑자 배열에서 찾기 실패:`, {
            localGapja, kasiGapja, 
            localFound: localIndex !== -1, 
            kasiFound: kasiIndex !== -1
          });
        }
      }
    } catch (error) {
      console.warn(`KASI API 기준점 호출 실패 (${year}-${month}-${referenceDay}):`, error);
    }
  }
  
  for (let day = 1; day <= daysInMonth; day++) {
    const date = new Date(year, month - 1, day);
    
    // 🎯 패턴 기반 60갑자 계산 (KASI 오프셋 적용)
    let gapja = get60갑자Sync(date);
    let lunarYear, lunarMonth, lunarDay, isLeapMonth, yearPillar, monthPillar;
    
    if (kasiReferenceData) {
      // KASI 오프셋 적용하여 정확한 갑자 계산 (오프셋이 0이어도 적용)
      if (!gapja || gapja === '❌오류') {
        console.error(`❌ 갑자 계산 실패: ${year}-${month}-${day}`, { gapja, date });
        gapja = '오류';
      } else {
        const localIndex = 갑자60순환.indexOf(gapja);
        if (localIndex !== -1) {
          let correctedIndex = (localIndex + gapjaOffset) % 60;
          if (correctedIndex < 0) correctedIndex += 60;
          
          const correctedGapja = 갑자60순환[correctedIndex];
          if (correctedGapja) {
            gapja = correctedGapja;
          } else {
            console.error(`❌ 보정된 갑자 조회 실패:`, { correctedIndex });
            gapja = '오류';
          }
          
          // 🔍 오프셋 적용 로그 (9월만)
          if (month === 9 && (day === 5 || day === 6)) {
            console.log(`🔧 9월 ${day}일 오프셋 적용:`, {
              로컬갑자: 갑자60순환[localIndex],
              로컬인덱스: localIndex,
              오프셋: gapjaOffset,
              보정인덱스: correctedIndex,
              최종갑자: gapja
            });
          }
        } else {
          console.error(`❌ 로컬 갑자 배열에서 찾기 실패:`, { gapja, day });
          gapja = '오류';
        }
      }
    } else {
      // KASI 데이터 없는 경우 안전장치
      if (!gapja || gapja === '❌오류') {
        gapja = '오류';
      }
    }
    
    // 음력 정보는 기준일 기준으로 추정 계산
    if (kasiReferenceData) {
      const dayDiff = day - referenceDay;
      let estimatedLunarDay = parseInt(kasiReferenceData.lunDay) + dayDiff;
      let estimatedLunarMonth = parseInt(kasiReferenceData.lunMonth);
      
      // 🔥 음력 월 경계 처리 (정확한 음력 달력 기준)
      // 음력 월은 29일 또는 30일이므로 정확한 처리 필요
      while (estimatedLunarDay > 30) {
        estimatedLunarDay -= 30; // 30일 기준으로 월 넘김
        estimatedLunarMonth++;
      }
      while (estimatedLunarDay < 1) {
        estimatedLunarDay += 30; // 30일 기준으로 이전 월
        estimatedLunarMonth--;
      }
      
      // 음력 월 범위 보정 (1-12월)
      lunarYear = year; // 기본값 설정
      if (estimatedLunarMonth > 12) {
        estimatedLunarMonth = 1;
        lunarYear = year + 1;
      } else if (estimatedLunarMonth < 1) {
        estimatedLunarMonth = 12;
        lunarYear = year - 1;
      }
      
      // lunarYear는 위에서 이미 보정됨 (월 경계 처리 시)
      lunarMonth = estimatedLunarMonth;
      lunarDay = estimatedLunarDay;
      isLeapMonth = kasiReferenceData.lunLeapmonth === '윤';
      
      // 🔥 입춘 기준 년주 계산 (60갑자 기준)
      yearPillar = get년주(date);
      monthPillar = kasiReferenceData.lunWolgeon || `${month}월주`;
    } else {
      // 완전 폴백: 로컬 계산만 사용
      lunarYear = year;
      lunarMonth = 0; // 음력 정보 없음
      lunarDay = 0;
      isLeapMonth = false;
      yearPillar = get년주(date);
      monthPillar = `${month}월주(추정)`;
    }
    
    // 음력 날짜 문자열 생성
    const lunarDate = lunarMonth === 0 || lunarDay === 0 
      ? `음력 정보 없음 (KASI API 오류)`
      : `음력 ${lunarYear}년 ${lunarMonth}월 ${lunarDay}일${isLeapMonth ? ' (윤달)' : ''}`;
    
    // 기본 정보 계산
    const 천간 = gapja[0] || '미';
    const 지지 = gapja[1] || '지';
    const 띠 = 띠동물[지지] || '미지';
    const 오행 = 오행매핑[천간] || '미지';
    const { 길일, 흉일 } = get길흉(gapja, date);
    const 손없는날 = is손없는날(date);
    const 절기 = get절기(date); // 🔥 동적 KASI 기반 24절기
    const 운세점수 = get운세점수(gapja, date);
    const 특이사항 = get특이사항(date, gapja, isLeapMonth); // 🔥 윤달 정보 포함
    
    // 🔍 9월 전체 날짜 갑자 검증 로그 (한시적)
    if (month === 9 && year === 2025) {
      console.log(`🔍 9월 ${day}일 갑자 검증:`, {
        day,
        finalGapja: gapja,
        dataSource: kasiReferenceData ? 'PATTERN_BASED' : 'LOCAL_ONLY'
      });
    }
    
    calendarDates.push({
      date,
      lunarDate,
      lunarYear,
      lunarMonth,
      lunarDay,
      isLeapMonth,
      gapja,
      zodiac: 띠,
      element: 오행,
      sonEobNeunNal: 손없는날,
      gilil: 길일,
      흉일,
      절기,
      운세점수,
      특이사항,
      solarCalendarType: 'solar',
      yearPillar,
      monthPillar,
    });
      
  }
  
  console.log(`🔮 패턴 기반 캘린더 생성 완료: ${year}년 ${month}월`);
  console.log(`✅ 생성된 날짜: ${daysInMonth}일 | 🎯 KASI 기준점: ${kasiReferenceData ? '성공' : '실패'}`);
  
  // 🔍 9월 5-6일 최종 검증 로그
  if (month === 9 && year === 2025) {
    const day5Data = calendarDates.find(d => d.date.getDate() === 5);
    const day6Data = calendarDates.find(d => d.date.getDate() === 6);
    console.log('🎯 9월 5-6일 최종 검증:', {
      '5일': day5Data ? `${day5Data.date.getDate()}일 = ${day5Data.gapja}` : '데이터없음',
      '6일': day6Data ? `${day6Data.date.getDate()}일 = ${day6Data.gapja}` : '데이터없음',
      '5일정답여부': day5Data?.gapja === '정축',
      '6일정답여부': day6Data?.gapja === '무인'
    });
  }
  
  
  return calendarDates;
};

// KASI API 오류 통계 조회
export const getKasiApiErrors = (): KasiApiError[] => {
  return [...kasiApiErrors];
};

// KASI API 오류 통계 요약
export const getKasiApiErrorSummary = () => {
  const total = kasiApiErrors.length;
  const byType = kasiApiErrors.reduce((acc, err) => {
    acc[err.errorType] = (acc[err.errorType] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
  
  return { total, byType, recentErrors: kasiApiErrors.slice(-5) };
};

// 월별 운세 메시지 생성
export const getMonthlyFortune = async (year: number, month: number): Promise<MonthlyFortune> => {
  const dates = await generateCalendarMonth(year, month);
  
  const bestDates = dates
    .filter(d => d.운세점수 >= 4)
    .sort((a, b) => b.운세점수 - a.운세점수)
    .slice(0, 5);
    
  const worstDates = dates
    .filter(d => d.운세점수 <= 2)
    .sort((a, b) => a.운세점수 - b.운세점수)
    .slice(0, 3);
    
  const importantDates = dates.filter(d => 
    d.절기 || d.gilil || d.특이사항.length > 1
  );
  
  const monthlyMessages = [
    '새해를 맞이하는 희망찬 달입니다.',
    '사랑의 기운이 가득한 달입니다.',
    '새로운 시작과 성장의 달입니다.',
    '안정과 조화를 찾는 달입니다.',
    '활발한 활동과 성취의 달입니다.',
    '균형과 화합이 중요한 달입니다.',
    '여름의 활기가 넘치는 달입니다.',
    '풍성한 수확을 기대하는 달입니다.',
    '변화와 적응의 지혜가 필요한 달입니다.',
    '깊이 있는 성찰과 준비의 달입니다.',
    '마무리와 정리가 중요한 달입니다.',
    '한 해를 돌아보며 감사하는 달입니다.'
  ];
  
  return {
    month,
    year,
    bestDates,
    worstDates,
    importantDates,
    monthlyMessage: monthlyMessages[month - 1]
  };
};

// 오늘의 운세 정보
export const getTodayFortune = async (): Promise<CalendarDate> => {
  const today = new Date();
  const year = today.getFullYear();
  const month = today.getMonth() + 1;
  const day = today.getDate();
  
  const monthData = await generateCalendarMonth(year, month);
  return monthData.find(d => d.date.getDate() === day) || monthData[0];
};

// ===== KASI API 연동 함수들 =====

// KASI API 기본 설정 (프록시 서버 경유)
const KASI_API_BASE = '/api/kasi'; // 프록시를 통해 CORS 문제 해결
const KASI_SERVICE_KEY = 'AR2zMFQPIPEq1WK5i1YIrWJO1jzGpBGGJUxFLQN5TXXWqFgBhC6r9WjKNFa5zWQF'; // 실제 키

// KASI API 전용 호출 함수 (백엔드 프록시 연동)
export const fetchKasiCalendarInfo = async (year: number, month: number, day: number): Promise<any> => {
  const dateStr = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
  
  try {
    // 백엔드 KASI 프록시를 통해 호출
    const proxyUrl = `/api/kasi/calendar?year=${year}&month=${month}&day=${day}`;
    
    console.log(`🔮 KASI API 프록시 호출: ${dateStr}`);
    
    const response = await fetch(proxyUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const result = await response.json();
    
    if (result.success && result.data) {
      console.log(`✅ KASI API 프록시 성공 (${dateStr}):`, result.data);
      return result.data; // lunYear, lunMonth, lunDay, lunIljin 등이 포함된 데이터
    } else {
      throw new Error(result.error || 'KASI API 프록시 응답 실패');
    }
    
  } catch (error) {
    console.warn(`⚠️  KASI API 프록시 호출 실패 (${dateStr}):`, error);
    return null; // 실패 시 null 반환하여 폴백 로직 실행
  }
};

// KASI XML 응답 파싱
const parseKasiXmlResponse = (xmlText: string): any => {
  try {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
    
    const item = xmlDoc.querySelector('item');
    if (!item) return null;

    return {
      lunDay: item.querySelector('lunDay')?.textContent || '',
      lunIljin: item.querySelector('lunIljin')?.textContent || '',
      lunLeapmonth: item.querySelector('lunLeapmonth')?.textContent || '평',
      lunMonth: item.querySelector('lunMonth')?.textContent || '',
      lunNday: item.querySelector('lunNday')?.textContent || '',
      lunSecha: item.querySelector('lunSecha')?.textContent || '',
      lunWolgeon: item.querySelector('lunWolgeon')?.textContent || '',
      lunYear: item.querySelector('lunYear')?.textContent || '',
      solWeek: item.querySelector('solWeek')?.textContent || '',
    };
  } catch (error) {
    console.warn('KASI XML 파싱 실패:', error);
    return null;
  }
};

// KASI API 전용 60갑자 계산 (폴백 없음)
export const getKasi60갑자 = async (date: Date): Promise<string> => {
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  
  const kasiData = await fetchKasiCalendarInfo(year, month, day);
  
  if (!kasiData) {
    throw new Error(`KASI API 응답 없음: ${year}-${month}-${day}`);
  }
  
  if (!kasiData.lunIljin) {
    throw new Error(`KASI API lunIljin 필드 없음: ${year}-${month}-${day}`);
  }
  
  // KASI에서 받은 일진(lunIljin)에서 한글 부분 추출
  // 예: "을해(乙亥)" -> "을해"
  const match = kasiData.lunIljin.match(/^([가-힣]+)/);
  if (!match) {
    throw new Error(`KASI API lunIljin 파싱 실패: ${kasiData.lunIljin}`);
  }
  
  return match[1];
};

// KASI API 전용 음력 정보 계산 (폴백 없음)
export const getKasi음력정보 = async (date: Date): Promise<{
  lunarDate: string;
  lunarYear: number;
  lunarMonth: number;
  lunarDay: number;
  isLeapMonth: boolean;
  yearPillar: string;
  monthPillar: string;
}> => {
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  
  const kasiData = await fetchKasiCalendarInfo(year, month, day);
  
  if (!kasiData) {
    throw new Error(`KASI API 응답 없음: ${year}-${month}-${day}`);
  }
  
  const lunarYear = parseInt(kasiData.lunYear);
  const lunarMonth = parseInt(kasiData.lunMonth);
  const lunarDay = parseInt(kasiData.lunDay);
  const isLeapMonth = kasiData.lunLeapmonth === '윤';
  
  if (!lunarYear || !lunarMonth || !lunarDay) {
    throw new Error(`KASI API 음력 날짜 파싱 실패: ${JSON.stringify(kasiData)}`);
  }
  
  const lunarDateStr = `음력 ${lunarYear}년 ${lunarMonth}월 ${lunarDay}일${isLeapMonth ? ' (윤달)' : ''}`;
  
  return {
    lunarDate: lunarDateStr,
    lunarYear,
    lunarMonth,
    lunarDay,
    isLeapMonth,
    yearPillar: kasiData.lunSecha || '연주미확인',
    monthPillar: kasiData.lunWolgeon || '월주미확인',
  };
};

// 24절기 정보 (KASI API 기반)
const 절기정보 = {
  1: [['소한', 5], ['대한', 20]],
  2: [['입춘', 4], ['우수', 19]],
  3: [['경칩', 6], ['춘분', 21]],
  4: [['청명', 5], ['곡우', 20]],
  5: [['입하', 6], ['소만', 21]],
  6: [['망종', 6], ['하지', 21]],
  7: [['소서', 7], ['대서', 23]],
  8: [['입추', 8], ['처서', 23]],
  9: [['백로', 8], ['추분', 23]],
  10: [['한로', 9], ['상강', 24]],
  11: [['입동', 8], ['소설', 23]],
  12: [['대설', 7], ['동지', 22]],
} as const;

export const getKasi절기 = (date: Date): string | null => {
  const month = date.getMonth() + 1;
  const day = date.getDate();
  
  const monthInfo = 절기정보[month as keyof typeof 절기정보];
  if (!monthInfo) return null;
  
  for (const [name, targetDay] of monthInfo) {
    if (Math.abs(day - targetDay) <= 1) { // ±1일 오차 허용
      return name;
    }
  }
  
  return null;
};

export default {
  generateCalendarMonth,
  getMonthlyFortune,
  getTodayFortune,
  get60갑자,
  getKasi60갑자,
  getKasi음력정보,
  getKasi절기,
  fetchKasiCalendarInfo,
  get음력변환,
  is손없는날,
  get길흉,
  get절기,
  get운세점수,
  get특이사항,
  get갑자표시,
  갑자한자매핑,
  천간,
  지지,
  띠동물,
  오행매핑
};